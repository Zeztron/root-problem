import fs from 'fs';
import readLine from 'readline';

import Trip from './interfaces/Trip';
import parseTime from './helpers/parseTime';

const inputFile = process.argv[2];

const readInterface = readLine.createInterface({
  input: fs.createReadStream(`${process.cwd()}/${inputFile}`),
});

// Representing a string array of all of the drivers - I'll need to keep track of the drivers
let drivers: string[] = [];

// This will get called for each line within the given input.
readInterface.on('line', (data) => {
  const eachLine = data.toString().split(' ');

  const [command, ...rest] = eachLine;
  if (command === 'Driver') {
    drivers.push(...rest);
  } else generateReport(rest);
});

// This will hold the report generated by the generateReport method.
let trips: Trip[] = [];
const generateReport = (data: string[]) => {
  const [name, startTime, endTime, distance] = data;
  const timeTraveled = parseTime(endTime) - parseTime(startTime);
  const speed = (Number(distance) / timeTraveled) * 60;

  trips.push({
    name,
    distance: Number(distance),
    timeTraveled,
    speed,
  });
};

/* 
  I want to append on trips done by the same driver so they arent different entries.
  Add the distance and then average the speed. 
*/
const filterResults = () => {
  return trips.reduce((previousValue: Trip[], currentValue: Trip) => {
    const driverName = currentValue.name;
    const sameTrip = previousValue.find(
      (trip: Trip) => trip.name === driverName
    );
    if (sameTrip) {
      sameTrip.timeTraveled += currentValue.timeTraveled;
      sameTrip.distance = sameTrip.distance += currentValue.distance;
    } else previousValue.push(currentValue);
    return previousValue;
  }, []);
  // .filter((trip: Trip) => trip.speed > 5 && trip.speed < 100);
};

/* 
  I want to add on Drivers who do not have Trips since it still must
  be included in the final output.
  I also need to sort them by most miles driven to least.
*/
const completeTripReport = (filteredResults: Trip[]) => {
  return drivers
    .map((driver: string) => {
      return {
        name: driver,
        distance: filteredResults.filter(
          (trip: Trip) => trip.name === driver
        )[0]?.distance,
        timeTraveled: filteredResults.filter(
          (trip: Trip) => trip.name === driver
        )[0]?.timeTraveled,
        speed:
          (filteredResults.filter((trip: Trip) => trip.name === driver)[0]
            ?.distance /
            filteredResults.filter((trip: Trip) => trip.name === driver)[0]
              ?.timeTraveled) *
          60,
      };
    })
    .sort(
      (tripA: Trip, tripB: Trip) =>
        (tripB.distance || -Infinity) - (tripA.distance || -Infinity)
    );
};

// This will get executed when all of the lines in the input are read.
readInterface.on('close', () => {
  const filteredResults: Trip[] = filterResults();

  const finalOutput: Trip[] = completeTripReport(filteredResults);

  finalOutput.forEach((trip: Trip) => {
    if (!trip.distance || !trip.speed) {
      console.log(`${trip.name}: 0 miles`);
    } else {
      console.log(
        `${trip.name}: ${Math.round(trip.distance)} miles @ ${Math.round(
          trip.speed
        )} mph`
      );
    }
  });
});
