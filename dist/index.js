"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var readline_1 = __importDefault(require("readline"));
var parseTime_1 = __importDefault(require("./helpers/parseTime"));
var inputFile = process.argv[2];
var readInterface = readline_1.default.createInterface({
    input: fs_1.default.createReadStream(process.cwd() + "/" + inputFile),
});
// Representing a string array of all of the drivers - I'll need to keep track of the drivers
var drivers = [];
// This will get called for each line within the given input.
readInterface.on('line', function (data) {
    var eachLine = data.toString().split(' ');
    var command = eachLine[0], rest = eachLine.slice(1);
    if (command === 'Driver') {
        drivers.push.apply(drivers, rest);
    }
    else
        generateReport(rest);
});
// This will hold the report generated by the generateReport method.
var trips = [];
var generateReport = function (data) {
    var name = data[0], startTime = data[1], endTime = data[2], distance = data[3];
    var timeTraveled = parseTime_1.default(endTime) - parseTime_1.default(startTime);
    var speed = (Number(distance) / timeTraveled) * 60;
    trips.push({
        name: name,
        distance: Number(distance),
        timeTraveled: timeTraveled,
        speed: speed,
    });
};
/*
  I want to append on trips done by the same driver so they arent different entries.
  Add the distance and then average the speed.
*/
var filterResults = function () {
    return trips.reduce(function (previousValue, currentValue) {
        var driverName = currentValue.name;
        var sameTrip = previousValue.find(function (trip) { return trip.name === driverName; });
        if (sameTrip) {
            sameTrip.timeTraveled += currentValue.timeTraveled;
            sameTrip.distance = sameTrip.distance += currentValue.distance;
        }
        else
            previousValue.push(currentValue);
        return previousValue;
    }, []);
    // .filter((trip: Trip) => trip.speed > 5 && trip.speed < 100);
};
/*
  I want to add on Drivers who do not have Trips since it still must
  be included in the final output.
  I also need to sort them by most miles driven to least.
*/
var completeTripReport = function (filteredResults) {
    return drivers
        .map(function (driver) {
        var _a, _b, _c, _d;
        return {
            name: driver,
            distance: (_a = filteredResults.filter(function (trip) { return trip.name === driver; })[0]) === null || _a === void 0 ? void 0 : _a.distance,
            timeTraveled: (_b = filteredResults.filter(function (trip) { return trip.name === driver; })[0]) === null || _b === void 0 ? void 0 : _b.timeTraveled,
            speed: (((_c = filteredResults.filter(function (trip) { return trip.name === driver; })[0]) === null || _c === void 0 ? void 0 : _c.distance) /
                ((_d = filteredResults.filter(function (trip) { return trip.name === driver; })[0]) === null || _d === void 0 ? void 0 : _d.timeTraveled)) *
                60,
        };
    })
        .sort(function (tripA, tripB) {
        return (tripB.distance || -Infinity) - (tripA.distance || -Infinity);
    });
};
// This will get executed when all of the lines in the input are read.
readInterface.on('close', function () {
    var filteredResults = filterResults();
    var finalOutput = completeTripReport(filteredResults);
    finalOutput.forEach(function (trip) {
        if (!trip.distance || !trip.speed) {
            console.log(trip.name + ": 0 miles");
        }
        else {
            console.log(trip.name + ": " + Math.round(trip.distance) + " miles @ " + Math.round(trip.speed) + " mph");
        }
    });
});
